{-# LANGUAGE ApplicativeDo       #-}
{-# LANGUAGE FlexibleContexts    #-}
{-# LANGUAGE NumericUnderscores  #-}
{-# LANGUAGE RecordWildCards     #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -fno-warn-unused-top-binds #-} -- Unused things generated by `createDomain`
{-# OPTIONS_GHC -fno-warn-orphans #-} -- Unused things generated by `createDomain`

{-| Board-level orchestration of the Heron Core. Marries up control logic from
    `Heron.Core.Core` with its memory components.
-}
module Heron.Board
  (
  -- * Simulation
    sim
  -- * Full system
  , board
  -- * Top-level synthesisable circuits
  , topEntity
  , testBench
  ) where

import           Clash.Annotations.TH
import           Clash.Explicit.Testbench
import           Clash.Prelude                         hiding (read)
import qualified Clash.Prelude.Testbench               as TB
import           Control.Arrow                         (second)
import qualified Data.List                             as L
import           Data.Maybe                            (fromMaybe, isJust)
import qualified Flite.TemplateSyntax                  as TS
import           Heron.Core.Collector
import           Heron.Core.Core
import           Heron.Core.Fifo
import           Heron.Core.Heap
import           Heron.Core.ParStack
import           Heron.Core.Stack
import           Heron.Core.Types
import           Heron.Encode                          (encProg)
import           Heron.External
import           Heron.Parameters
import           Heron.Primitives.DualPortRam
import qualified Heron.Primitives.ReadFirstDualPortRam as RF
import           Heron.Template
import           Heron.TemplateTH
import           Language.Haskell.TH                   hiding (Type)
import           RetroClash.Barbies

-- | Complete system with all control inputs and outputs exposed
board
  :: (HiddenClockResetEnable dom)
  => Heap dom HeapNode 2 HeapSize
  -- ^ Heap memory architecture
  -> Heap dom Template 2 RomSize
  -- ^ Template memory architecture
  -> Heap dom GCNode 2 HeapSize
  -- ^ GC memory architecture
  -> Signal dom (RamOp RomSize Template)
  -- ^ External interface into template memory (for loading user application)
  -> Signal dom (Maybe TemplAddr       )
  -- ^ Signal to start evaluation at given template address
  -> Signal dom HeapAddr
  -- ^ GC threshold (if any freelist gets below the given length, GC is triggered)
  -> ( Signals dom CPUIn
     , Signals dom CPUOut
     , Signals dom GCIn
     , Signals dom GCOut
     )
  -- ^ Expose all control signals for debugging
board heapPrim tmplPrim gcPrim romCtrl begin gcThres = (CPUIn{..}, CPUOut{..}, GCIn{..}, GCOut{..})
  where
    CPUOut{..} = cpu CPUIn{..}
    GCOut{..} = gc GCIn{..}

    uStkRam = blockRam1 ClearOnReset (SNat @UStkSize) Nothing
    aStkRam = blockRam1 ClearOnReset (SNat @AStkSize) Nothing
    pStkRam = blockRam1 ClearOnReset (SNat @PStkSize) Nothing
    mutBufRam = blockRam1 ClearOnReset (SNat @GCMutBufSize) Nothing

    uStkIn = newStack uStkRam $ bundle (_uStkPush, _uStkPop)
    aStkIn = newStack aStkRam $ bundle (_aStkPush, _aStkPop)
    pStkIn = newStack pStkRam $ bundle (_pStkPush, _pStkPop)
    vStkIn = newCachedParStack _vStkOut _stkSnoopAddr
    (heapOut', gcAccess) = unbundle $ liftA2 arbitrateGC _heapOut (maybe RamNoOp RamRead <$> _heapMemOut)
    heapIn = heapPrim heapOut'
    tmplIn = head . read <$>
               (tmplPrim . bundle $
               (RamRead <$> _tmplOut) :> romCtrl :> Nil)
    gcCmd  = register NoCmd _cmd

    nextAddrs = liftA2 (zipWith getNextAddrs) (read <$> gcMemIn) $
                liftA2 (zipWith swpA) (allocd <$> request) (register (repeat (Nothing, Nothing)) _nextFree)

    gcMemIn = gcPrim _gcMemOut
    heapMemIn = mux (register False gcAccess) (Just . head . read <$> heapIn)
                                              (pure Nothing)
    request  = register RNothing $
               TB.assert "ERROR: Mutator allocating after bubble prediction"
                 ( (fold (||) . allocd <$> _gcRequest) .&&. bubble )
                 ( pure False )
                 _gcRequest
    stkIn = bundle (size <$> vStkIn, head . _snoops <$> vStkIn) -- Passed to GC for root ID
    update' = register False (isJust <$> _updateAddr)
    updatePush = mux update' (Just . head . read <$> heapIn) (pure Nothing)
    updateIn = newFifo 0 mutBufRam (bundle (updatePush, _updatePop))
    bubble = register False _allocBubble
    triggerThres = register 0 gcThres

    getNextAddrs rd = fromMaybe (tailPtr rd)
    swpA x = if x then snd else fst
    allocd (RAlloc as) = as
    allocd _           = repeat False

-- | A version of `board` with fewer input/output pins. Makes it easier to
-- synthesise in Vivado in isolation.
boardFewerIOBs
  :: (HiddenClockResetEnable dom)
  => Heap dom HeapNode 2 HeapSize
  -> Heap dom Template 2 RomSize
  -> Heap dom GCNode 2 HeapSize
  -> Signal dom (RamOp RomSize Template) -- Interface to template memory
  -> Signal dom Bool                     -- Start reduction
  -> Signal dom HeapAddr                 -- GC threshold
  -> Signal dom (CPUStats, Maybe Atom)
boardFewerIOBs heapPrim tmplPrim gcPrim tOp go gcThres = delay (unpack 0, Nothing) $ delay (unpack 0, Nothing) out
  where
    out = _result . pick $ board heapPrim tmplPrim gcPrim tOp goAddr gcThres
    goAddr = mux go (pure $ Just 0) (pure Nothing)
    pick (_,x,_,_) = x
    -- pick (_,x) = x

createDomain vSystem{vName="DomIn"  , vPeriod=  snatToNum (SNat @ClkT)}

-- | The main synthesisable system with explicit clock, resets, enables, and
-- port names.
topEntity
  :: "clk" ::: Clock DomIn
  -- ^ Input clock
  -> "rst" ::: Reset DomIn
  -- ^ Reset
  -> "en"  ::: Enable DomIn
  -- ^ Enable
  -> "codeWE"   ::: Signal DomIn Bool
  -- ^ Template memeory write enable
  -> "codeAddr" ::: Signal DomIn TemplAddr
  -- ^ Template memeory address
  -> "codeData" ::: Signal DomIn (BitVector (BitSize Template))
  -- ^ Template memeory data
  -> "go"       ::: Signal DomIn Bool
  -- ^ Start signal
  -> "gcThres"  ::: Signal DomIn HeapAddr
  -- ^ GC threshold signal
  -> ("ret"    ::: Signal DomIn Atom
     ,"stats"  ::: Signal DomIn CPUStats
     ,"retVld" ::: Signal DomIn Bool
     )
  -- ^ Return result atom
topEntity clkIn rstIn enIn cWe cAddr cData go gcThres =
  ( fmap (fromMaybe (unpack 0) . snd) ret
  , fmap fst                          ret
  , fmap (isJust . snd)               ret
  )
  where
    cOp = mux cWe (RamWrite <$> cAddr <*> fmap unpack cData)
                  (pure RamNoOp)

    wrapHeap = withClockResetEnable @DomIn clkIn rstIn enIn $
               newHeap $ specialiseHeap heapConfig
                           (dpRam    @HeapSize @DomIn @HeapNode UltraRam   )
                           (RF.dpRam @HeapSize @DomIn @HeapNode RF.BlockRam)

    wrapTmpl = withClockResetEnable @DomIn clkIn rstIn enIn $
               newHeap $
               dpRam @RomSize @DomIn @Template BlockRam

    wrapGc   = withClockResetEnable @DomIn clkIn rstIn enIn $
               newHeap $
               RF.dpRam @HeapSize @DomIn @GCNode RF.BlockRam

    ret = withClockResetEnable @DomIn clkIn rstIn enIn $
          boardFewerIOBs @DomIn wrapHeap wrapTmpl wrapGc cOp go gcThres

{-# NOINLINE topEntity #-}
makeTopEntity 'topEntity

-- | Simulate `board` at a Haskell-level
sim :: Int
    -- ^ Bound on cycle count before termination (pass `maxBound` for maximumg)
    -> TS.Prog
    -- ^ Input program as F-lite templates
    -> IO (Int, CPUStats, Atom)
    -- ^ (Simulated cycle count, return value)
sim limit p = do
  -- Test input loads program into code memory, then says GO
  let (initAddr, prog) = encProg p
  let simIn  = L.concat
                 [ L.zipWith (\a t -> (RamWrite a t, Nothing, gcThres)) [0..] prog
                 , L.replicate (heapSize `div` 2 + 1 - L.length prog) (RamNoOp, Nothing, gcThres)
                 , [(RamNoOp, Just initAddr, gcThres)]
                 , L.repeat (RamNoOp, Nothing, gcThres)
                 ]
  -- Run sim
  let simOut = L.take limit $
               L.drop (2 + (heapSize `div` 2)) $
               simulate @System (reshape (board
                                         (newHeap $
                                          specialiseHeap heapConfig
                                            (dpRam UltraRam      )
                                            (RF.dpRam RF.UltraRam))
                                          (newHeap (dpRam UltraRam))
                                          (newHeap (RF.dpRam RF.UltraRam))
                                          )) -- 50% GC threshold
                        simIn

  -- Report results
  let doneAt = L.findIndex (isJust . snd . _result . snd') simOut
  case doneAt of
    Nothing  -> do
      writeFile "/tmp/heron_sim.log" ""
      mapM_ (\(i,s) -> appendFile "/tmp/heron_sim.log" ("Cycle " L.++ show i L.++ "===================") >>
                       appendFile "/tmp/heron_sim.log" (showSample s)) $ L.zip [0 :: Integer ..] simOut
      error $ L.concat ["Core still running after ", show limit, " cycles. Aborting."]
    Just idx -> do putStrLn $ L.concat ["Finished after ", show (idx-1), " cycles: "]
                   let (stats, ans) = second fromJustX . _result . snd' $ simOut L.!! idx
                   debugRemainings idx simOut
                   pure (idx - 1, stats, ans)
  where
    debugRemainings idx =
      writeFile "/tmp/heron_balance.csv" . unlines . ("A,B,C,D" :) .
      L.map (\(_,_,_,x) -> unwords [show (fst $ head $ _remaining x), ", "
                                   ,show (snd $ head $ _remaining x), ", "
                                   ,show (fst $ last $ _remaining x), ", "
                                   ,show (snd $ last $ _remaining x)
                                   ]) .
      L.take idx

    reshape dut = bundle . (\(a,b,c,d)->(bundle a, bundle b, bundle c, bundle d)) . uncurry3 dut . unbundle
    showSample (is, os, gis, gos) = L.unlines
      [ "Stk top   : " L.++ showX (read (vStkIn is))
      , "Heap Ctrls: " L.++ showX  (_heapOut os)
      , "Result    : " L.++ showX (snd $ _result os)
      , "Stats     : " L.++ showX (fst $ _result os)
      , "AStk top  : " L.++ showX (read (aStkIn is))
      , "Outs      : " L.++ showX os
      , "Ins       : " L.++ showX is
      , "GC Ins    : " L.++ showX gis
      , "GC Outs   : " L.++ showX gos
      ]
    snd' (_,x,_,_) = x
    heapSize = snatToNum (SNat @HeapSize)
    gcThres  = defGcThreshold

-- | Simulate `board` at a verilog-level. Uses Clash's `outputVerifier'` to
-- produce a verilog testbench. Assertion errors will be thrown if answer is
-- wrong, too early, or too late.
--
-- For now, this is specialised to only the adjoxo benchmark using Template
-- Haskell.
testBench :: Signal DomIn Bool
testBench = done
 where
  -- Use Template Haskell to run C emulator and return benchmark's
  -- expected cycles (as type-level Nat), expected return atom,
  -- and it's compiled templates (as a Vec)
  (expCycles, expAtom, tmpls)
            = $( do prog <- runIO $ getProjectFile "tests/benchmarks/fib.fl" >>= compileBenchmark
                    let code = snd (encProg prog)
                    tmplsVec <- listToVecTH code
                    (emuRet, emuCycles) <- runIO (runEmulator prog)
                    emuRetAtom <- [| PrimInt emuRet |]
                    emuCyclesS <- promoteIntTH emuCycles
                    let tup = TupE [Just emuCyclesS, Just emuRetAtom, Just tmplsVec]
                    return tup
               )

  tmplNoOp = (False, 0, unpack minBound)
  testInput = unzip $ replicate d30 (tmplNoOp, False) ++
                      -- Wait for enable/reset
                      zipWith (\t a -> ((True, a, t), False)) tmpls (iterateI (+1) 0) ++
                      -- Write templates
                      -- replicate (SNat @(HeapSize `Div` 2)) (tmplNoOp, False) ++
                      -- Wait for GC memory to initialise
                      singleton (tmplNoOp, True) ++
                      singleton (tmplNoOp, False)

  (tmplWe, tmplAddr, tmplData)
     = unbundle $ stimuliGenerator clkIn rstIn (fst testInput)
  tmplBits = fmap pack tmplData
  go = stimuliGenerator clkIn rstIn (snd testInput)
  gcThres = pure defGcThreshold

  done = withClockResetEnable clkIn rstIn enIn assertReturn expCycles expAtom $
         topEntity clkIn rstIn enIn tmplWe tmplAddr tmplBits go gcThres

  enIn           = enableGen  @DomIn
  clkIn          = tbClockGen @DomIn (fmap not done)
  rstIn          = resetGen   @DomIn

defGcThreshold :: HeapAddr
defGcThreshold = perc d47
  where
    perc x = snatToNum $
             divSNat (mulSNat x (SNat @(HeapSize `Div` 4)))
                     d100

assertReturn
  :: HiddenClockResetEnable dom
  => SNat n
  -> Atom
  -> (Signal dom Atom, Signal dom CPUStats, Signal dom Bool)
  -> Signal dom Bool
assertReturn lim ans (ret, s, vld) =
  TB.assert "FAIL: BAD RETURN VALUE"
    (pure ans .==. ret)
    end
    (delay False end)
  where
    muts = _mutCycles <$> s
    -- Finishing correctly only counts when we report the expected mutator
    -- cycles too
    finished = vld .&&. muts .==. pure (snatToNum lim)
    -- Timeout after initialisation time + twice the expected mutator cycles.
    timeOut = riseEvery $ addSNat (SNat @(HeapSize `Div` 2)) $
                          mulSNat d2 lim
    end = timeOut .||. finished

uncurry3 :: (t1 -> t2 -> t3 -> t4) -> (t1, t2, t3) -> t4
uncurry3 f (a,b,c) = f a b c
