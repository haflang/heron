module Flite.Prelude(
        prelude
    ) where

prelude :: String
prelude = unlines
  ["-- | Int"
  ,""
  ,"min x y = if x <= y then x else y"
  ,""
  ,"max x y = if x <= y then y else x"
  ,""
  ,"abs n = if 0 <= n then n else 0 - n"
  ,""
  ,"div x y = case divMod x y of (d, m) -> d"
  ,""
  ,"mod x y = case divMod x y of (d, m) -> m"
  ,""
  ,"divMod x y = let  y2 = y + y in"
  ,"             if y2 <= x"
  ,"               then case divMod x y2 of"
  ,"                      (d2, m2) ->"
  ,"                        let d2x2 = d2 + d2"
  ,"                        in if y <= m2"
  ,"                             then (d2x2 + 1, m2 - y)"
  ,"                             else (d2x2, m2)"
  ,"               else if y <= x"
  ,"                      then (1, x - y)"
  ,"                      else (0, x    )"
  ,""
  ,"succ x = x + 1"
  ,""
  ,"pred x = x - 1"
  ,""
  ,"-- | Bool"
  ,""
  ,"(||) False x = x"
  ,"(||) True x  = True"
  ,""
  ,"(&&) False x = False"
  ,"(&&) True x  = x"
  ,""
  ,"(>) m n = if m <= n then False else True"
  ,""
  ,"not False = True"
  ,"not True  = False"
  ,""
  ,"-- | Maybe"
  ,""
  ,"isNothing Nothing  = True"
  ,"isNothing (Just x) = False"
  ,""
  ,"isJust Nothing  = False"
  ,"isJust (Just x) = True"
  ,""
  ,"fromJust (Just x) = x"
  ,""
  ,"maybe n j Nothing  = n"
  ,"maybe n j (Just x) = j x"
  ,""
  ,"-- | Reshape"
  ,""
  ,"flip f y x = f x y"
  ,""
  ,"const c x = c"
  ,""
  ,"id x = x"
  ,""
  ,"fst (x, y) = x"
  ,""
  ,"snd (x, y) = y"
  ,""
  ,"curry f x y = f (x, y)"
  ,""
  ,"uncurry f (x,y) = f x y"
  ,""
  ,"(.) f g x = f (g x)"
  ,""
  ,"($) f x   = f (x)"
  ,""
  ,"-- | List"
  ,""
  ,"map f []         = []"
  ,"map f (x : xs) = f x : map f xs"
  ,""
  ,"maximum (x : xs) = maximumGo x xs"
  ,"maximumGo m [] = m"
  ,"maximumGo m (x : xs) ="
  ,"  if m <= x"
  ,"    then maximumGo x xs"
  ,"    else maximumGo m xs"
  ,""
  ,"foldr1 f [x] = x"
  ,"foldr1 f (x : y : ys) = f x (foldr1 f (y : ys))"
  ,""
  ,"sum xs = sumAcc 0 xs"
  ,"sumAcc acc [] = acc"
  ,"sumAcc acc (x : xs) = sumAcc (x + acc) xs"
  ,""
  ,"null []       = True"
  ,"null (x : xs) = False"
  ,""
  ,"zip [] ys = []"
  ,"zip (x : xs) [] = []"
  ,"zip (x : xs) (y : ys) = (x, y) : zip xs ys"
  ,""
  ,"unzip []             = ([],[])"
  ,"unzip ((x, y) : xys) ="
  ,"  let  u = unzip xys"
  ,"  in  (x : (fst u), y : (snd u))"
  ,""
  ,"length xs = lengthAcc 0 xs"
  ,""
  ,"lengthAcc acc [] = acc"
  ,"lengthAcc acc (x : xs) = lengthAcc (acc + 1) xs"
  ,""
  ,"(++) [] ys = ys"
  ,"(++) (x : xs) ys = x : (xs ++ ys)"
  ,""
  ,"repeat x = x : repeat x"
  ,""
  ,"all p [] = True"
  ,"all p (x : xs) = (p x) && (all p xs)"
  ,""
  ,"head (x : xs) = x"
  ,""
  ,"unlines []       =  \"\""
  ,"unlines (s : ss) =  s ++ ('\\n' : unlines ss)"
  ,""
  ,"tail (x : xs) = xs"
  ,""
  ,"last (x : xs)"
  ," = if null xs"
  ,"     then x"
  ,"     else last xs"
  ,""
  ,"enumFromTo m n"
  ," = if m <= n"
  ,"     then m : enumFromTo (succ m) n"
  ,"     else []"
  ,""
  ,"init [x]          = []"
  ,"init (x : (y : ys)) = x : init (y : ys)"
  ,""
  ,"elem x []       = False"
  ,"elem x (y : ys) ="
  ,"  if x == y"
  ,"    then True"
  ,"    else elem x ys"
  ,""
  ,"(!!) (x : xs) n ="
  ,"  if n == 0"
  ,"    then x"
  ,"    else xs !! (n - 1)"
  ,""
  ,"concatMap f [] = []"
  ,"concatMap f (x : xs) = f x ++ concatMap f xs"
  ,""
  ,"and []       = True"
  ,"and (b : bs) = if b then and bs else False"
  ,""
  ,"any p []       = False"
  ,"any p (x : xs) = (p x) || (any p xs)"
  ,""
  ,"filter p []      = []"
  ,"filter p (x : xs) ="
  ,"  if p x"
  ,"    then x : filter p xs"
  ,"    else filter p xs"
  ,""
  ,"foldl f a [] = a"
  ,"foldl f a (x : xs) = foldl f (f a x) xs"
  ,""
  ,"foldr f z []       = z"
  ,"foldr f z (x : xs) = f x (foldr f z xs)"
  ,""
  ,"zipWith f []       []       = []"
  ,"zipWith f []       (y : ys) = []"
  ,"zipWith f (x : xs) []       = []"
  ,"zipWith f (x : xs) (y : ys) = f x y : zipWith f xs ys"
  ,""
  ,"replicate n x ="
  ,"  if n == 0"
  ,"    then []"
  ,"    else x : replicate (n - 1) x"
  ,""
  ,"lookup a [] = Nothing"
  ,"lookup a ((b, c) : rest) ="
  ,"  if a == b"
  ,"    then Just c"
  ,"    else lookup a rest"
  ]
