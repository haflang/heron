id x = x

const c x = c

inc n = n + 1

dec n = n - 1

min x y = if x <= y then x else y

max x y = if x <= y then y else x

abs n = if 0 <= n then n else 0 - n

plus a b = a + b

minus a b = a - b

no Nothing = True
no (Just x) = False

maybe n j Nothing  = n
maybe n j (Just x) = j x

con True  q = q
con False q = False

dis True  q = True
dis False q = q

fst (x, y) = x

snd (x, y) = y

cross (f, g) (x, y) = (f x, g y)

null []       = True
null (x : xs) = False

append []       ys = ys
append (x : xs) ys = x : append xs ys

elemAt (x : xs) n =
  if n == 0
    then x
    else elemAt xs (n - 1)

map f [] = []
map f (x : xs) = f x : map f xs

concatMap f [] = []
concatMap f (x : xs) = append (f x) (concatMap f xs)

any p []       = False
any p (x : xs) = dis (p x) (any p xs)

foldr f z []       = z
foldr f z (x : xs) = f x (foldr f z xs)

sumAcc acc [] = acc
sumAcc acc (x : xs) = sumAcc (acc + x) xs

sum xs = sumAcc 0 xs

unzip []             = ([],[])
unzip ((x, y) : xys) =
  let  u = unzip xys
  in  (x : (fst u), y : (snd u))

kindToChar k =
  case k of
    King   -> 'K'
    Queen  -> 'Q'
    Rook   -> 'R'
    Bishop -> 'B'
    Knight -> 'N'
    Pawn   -> 'P'

isKing k = kindToChar k == 'K'

pieceAt (Board wkss bkss) sq =
  pieceAtWith sq White (pieceAtWith sq Black Nothing bkss) wkss

pieceAtWith sq c n [] = n
pieceAtWith sq c n ((k, s) : xs) =
  if sameSquare s sq
    then Just (c, k)
    else pieceAtWith sq c n xs

emptyAtAll (Board wkss bkss) e =
  emptyAtAllAnd e (emptyAtAllAnd e True bkss) wkss

emptyAtAllAnd e b []            = b
emptyAtAllAnd e b ((k, s) : xs) =
  if e s
    then False
    else emptyAtAllAnd e b xs

rmPieceAt White sq (Board wkss bkss) = Board (rPa sq wkss) bkss
rmPieceAt Black sq (Board wkss bkss) = Board wkss (rPa sq bkss)

rPa sq (ks : kss) =
  case ks of
    (k, s) ->
      if sameSquare s sq
        then kss
        else ks : rPa sq kss

putPieceAt sq (c, k) (Board wkss bkss) =
  case c of
    White -> Board ((k, sq) : wkss) bkss
    Black -> Board wkss ((k, sq) : bkss)

kingSquare c b = kSq (forcesColoured c b)

kSq ((k, s) : kss) =
  if isKing k then s else kSq kss

opponent Black = White
opponent White = Black

colourOf (c, k) = c
kindOf   (c, k) = k

sameColour White White = True
sameColour White Black = False
sameColour Black White = False
sameColour Black Black = True

rank (f, r) = r
file (f, r) = f

sameSquare (f1, r1) (f2, r2) = con (f1 == f2) (r1 == r2)

onboard (p, q) =
  con (con (1 <= p) (p <= 8))
      (con (1 <= q) (q <= 8))

forcesColoured White (Board wkss bkss) = wkss
forcesColoured Black (Board wkss bkss) = bkss

moveDetailsFor c bd =
  concatMap (movesForPiece c bd) (forcesColoured c bd)

movesForPiece c bd p =
  concatMap (tryMove c bd p) (rawmoves c p bd)

tryMove c bd (k, sqFrom) (Move sqTo mcp mpp) =
  let p   = (c, k)
      bd1 = rmPieceAt c sqFrom bd
      pp  = maybe p id mpp
      bd2 = maybe (putPieceAt sqTo pp bd1)
                  (const (putPieceAt sqTo pp
                           (rmPieceAt (opponent c) sqTo bd1)))
                  mcp
  in if kingincheck c bd2
       then []
       else [(MoveInFull p sqFrom (Move sqTo mcp mpp), bd2)]


rawmoves c (k, sq) bd =
  let m = case k of
            King   -> kingmoves
            Queen  -> queenmoves
            Rook   -> rookmoves
            Bishop -> bishopmoves
            Knight -> knightmoves
            Pawn   -> pawnmoves
  in m c sq bd

bishopmoves c sq bd =
  append (moveLine bd c sq (cross (dec, inc))) $
  append (moveLine bd c sq (cross (inc, inc))) $
  append (moveLine bd c sq (cross (dec, dec)))
         (moveLine bd c sq (cross (inc, dec)))

rookmoves c sq bd =
  append (moveLine bd c sq (cross (dec, id))) $
  append (moveLine bd c sq (cross (inc, id))) $
  append (moveLine bd c sq (cross (id, dec)))
         (moveLine bd c sq (cross (id, inc)))

moveLine bd c sq inc =
  let incsq = inc sq
  in if onboard incsq
       then case pieceAt bd incsq of
              Nothing -> Move incsq Nothing Nothing : moveLine bd c incsq inc
              Just p  -> if sameColour (colourOf p) c
                           then []
                           else [Move incsq (Just p) Nothing]
       else []


kingmoves c (p, q) bd =
  let pi = p + 1
      pd = p - 1
      qi = q + 1
      qd = q - 1
  in sift c bd [] [(pd,qi), (p ,qi), (pi,qi)
                  ,(pd,q ),          (pi,q )
                  ,(pd,qd), (p ,qd), (pi,qd)
                  ]

knightmoves c (p, q) bd =
  let pi = p + 1
      pd = p - 1
      qi = q + 1
      qd = q - 1
      pi2 = p + 2
      pd2 = p - 2
      qi2 = q + 2
      qd2 = q - 2
  in sift c bd [] [     (pd ,qi2),      (pi ,qi2)
                  ,(pd2,qi ),                (pi2,qi)
                  ,(pd2,qd ),                (pi2,qd)
                  ,     (pd ,qd2),      (pi ,qd2)
                  ]

sift c bd ms []           = ms
sift c bd ms (sq : sqs) =
  if onboard sq
    then case pieceAt bd sq of
           Nothing -> sift c bd (Move sq Nothing Nothing : ms) sqs
           Just p  -> if sameColour (colourOf p) c
                        then sift c bd ms sqs
                        else sift c bd (Move sq (Just p) Nothing : ms) sqs
    else sift c bd ms sqs

pawnmoves c (p, q) bd =
  let fwd = case c of
              White -> 1
              Black -> 0 - 1
      on1  = (p, q + fwd)
      on2  = (p, q + fwd + fwd)
      mov2 = if con (secondRank c q) (no (pieceAt bd on2))
               then [Move on2 Nothing Nothing]
               else []
      movs = if no (pieceAt bd on1)
               then append (promote c on1 Nothing) mov2
               else []
      dii  = (p + 1, q + fwd)
      did  = (p - 1, q + fwd)
      caps = append (promoteCap c dii bd) (promoteCap c did bd)
  in append movs caps

promoteCap c sq bd =
  let mcp = pieceAt bd sq
  in case mcp of
       Nothing  -> []
       Just p   -> if sameColour (colourOf p) c
                     then []
                     else promote c sq mcp

promote c sq mcp =
  if lastRank c (rank sq)
    then map (Move sq mcp)
             [Just (c, Queen)
             ,Just (c, Rook)
             ,Just (c, Bishop)
             ,Just (c, Knight)
             ]
    else [Move sq mcp Nothing]

secondRank White r = r == 2
secondRank Black r = r == 7

lastRank White r = r == 8
lastRank Black r = r == 1

queenmoves c sq bd = append (bishopmoves c sq bd) (rookmoves c sq bd)

kingincheck c bd =
  any (kingInCheckFrom c bd) (forcesColoured (opponent c) bd)

kingInCheckFrom c bd (f, (x, y)) =
  case kingSquare c bd of
    (xk, yk) ->
      case f of
        King   -> con (abs (x - xk) <= 1)
                      (abs (y - yk) <= 1)
        Queen  -> dis (kingInCheckFrom c bd (Rook  , (x, y)))
                      (kingInCheckFrom c bd (Bishop, (x, y)))
        Rook   -> dis (con (x == xk)
                           (emptyAtAll bd (filePath xk y yk)))
                      (con (y == yk)
                           (emptyAtAll bd (rankPath yk x xk)))
        Bishop -> dis (con (x - y == xk - yk)
                           (emptyAtAll bd (diagPath minus (xk - yk) x xk)))
                      (con (x + y == xk + yk)
                           (emptyAtAll bd (diagPath plus  (xk + yk) x xk)))
        Knight -> dis (con (abs (x - xk) == 2) (abs (y - yk) == 1))
                      (con (abs (x - xk) == 1) (abs (y - yk) == 2))
        Pawn   -> con (abs (x - xk) == 1)
                      (yk == onFor c y  )

onFor Black = inc
onFor White = dec

filePath xk yFrom yTo (x, y) =
  let ylo = min yFrom yTo + 1
      yhi = max yFrom yTo - 1
  in con (x == xk)
         (con (ylo <= y) (y <= yhi))

rankPath yk xFrom xTo (x, y) =
  let xlo = min xFrom xTo + 1
      xhi = max xFrom xTo - 1
  in  con (y == yk)
          (con (xlo <= x) (x <= xhi))

diagPath op d xFrom xTo (x, y) =
  let xlo = min xFrom xTo + 1
      xhi = max xFrom xTo - 1
  in  con (op x y == d)
          (con (xlo <= x) (x <= xhi))

solve bd c n = showResult (solution bd c (n + n - 1))

solution bd c n =
  let mds = moveDetailsFor c bd
  in  foldr (solnOr c n) Nothing mds

solnOr c n (mif, b) other =
  case replies b (opponent c) (n - 1) of
    Nothing -> other
    Just rs -> if null rs
                 then if kingincheck (opponent c) b
                        then Just (Solution mif [])
                        else other
                 else Just (Solution mif rs)

replies bd c n =
  let mds = moveDetailsFor c bd
  in if n == 0
       then if null mds
              then Just []
              else Nothing
       else foldr (solnAnd c n) (Just []) mds

solnAnd c n (mif, b) rest =
  case solution b (opponent c) (n - 1) of
    Nothing -> Nothing
    Just s  -> case rest of
                 Nothing -> Nothing
                 Just ms -> Just ((mif, s) : ms)

showResult Nothing  = 0
showResult (Just s) = size s

size (Solution mif rs) = sum (map size (snd (unzip rs))) + 1

main =
  let
   problem =
    (Board
      [(Queen , (6, 6))
      ,(Bishop, (5, 5))
      ,(King  , (6, 5))
      ]
      [(King  , (4, 4))
      ]
    ,Pair Black 1)
  in solveProblem problem

solveProblem (bd, (c, n)) = solve bd c n
