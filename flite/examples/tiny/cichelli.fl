min m n = if m <= n then m else n
max m n = if m <= n then n else m
gt  m n = if m <= n then False else True

head (x : xs) = x

last (x : xs) = if null xs then x else last xs

null []       = True
null (x : xs) = False

length xs = lengthAcc 0 xs

lengthAcc acc [] = acc
lengthAcc acc (x : xs) = lengthAcc (acc + 1) xs

append []       ys = ys
append (x : xs) ys = x : append xs ys

map f []         = []
map f (x : xs) = f x : map f xs

concatMap f []       = []
concatMap f (x : xs) = append (f x) (concatMap f xs)

elem x []       = False
elem x (y : ys) =
  if x == y
    then True
    else elem x ys

foldr f z []       = z
foldr f z (x : xs) = f x (foldr f z xs)

filter p []       = []
filter p (x : xs) =
  if p x
    then x : (filter p xs)
    else filter p xs

enumFromTo m n =
  if m <= n
    then m : (enumFromTo ((+) m 1) n)
    else []

assoc x (Cons (y, z) yzs) =
  if x == y then z else assoc x yzs

assocm x []             = Nothing
assocm x ((y, z) : yzs) =
  if x == y then Just z else assocm x yzs

subset []       ys = True
subset (x : xs) ys =
  if elem x ys then subset xs ys else False

union xs ys = foldr ins xs ys

ins x ys = if elem x ys then ys else x : ys

histo xs = foldr histins [] xs

histins x []         = [(x, 1)]
histins x ((y,n) : yns) =
    if x == y
      then (y, n + 1) : yns
      else (y,n) : histins x yns

sorted lt = foldr (ordins lt) []

ordins lt x []       = [x]
ordins lt x (y : ys) =
  if lt x y
    then x : y : ys
    else y : ordins lt x ys

ends (K s a z n) = [a,z]

firstLetter (K s a z n) = a

lastLetter (K s a z n) = z

freqSorted ks =
  let ft = freqTabOf ks
  in (sorted (decreasingFrequencyIn ft) ks, length ft)

decreasingFrequencyIn ft (K s0 a x n0) (K s1 b y n1) =
  let freq = flip assoc ft
  in gt (freq a + freq x) (freq b + freq y)

flip f x y = f y x

freqTabOf ks = histo (concatMap ends ks)

blocked = blockedWith []

blockedWith ds []       = []
blockedWith ds (k : ks) =
  let dsk = union ds (ends k)
      eks = endsSubset dsk
      det = filter eks ks
      rest = filter (non eks) ks
  in k : append det (blockedWith dsk rest)

non f x = if f x then False else True

endsSubset ds k = subset (ends k) ds

enKey k = K k (head k) (last k) (length k)

hashAssoc (Hash hs hf) = hf

findhash mv ks =
  case hashes mv (length ks) ks (Hash (H Nothing Nothing []) []) of
    (Hash s f : hs) -> Just f
    []       -> Nothing

hashes maxval nk []       h = [h]
hashes maxval nk (k : ks) h =
  concatMap (hashes maxval nk ks) $
  concatMap (insertKey nk k)      $
  concatMap (assignUpto maxval (lastLetter k))
            (assignUpto maxval (firstLetter k) h)
  --TODO Indent improvements here?

assignUpto maxval c h =
  case assocm c (hashAssoc h) of
    Nothing -> map (assign c h) (enumFromTo 0 maxval)
    Just v  -> [h]

insertKey nk k (Hash hs hf) =
  case hinsert nk (hash hf k) hs of
    Nothing    -> []
    Just hsNew -> [Hash hsNew hf]

assign c (Hash hs hf) v = Hash hs ((c, v) : hf)

hinsert nk h (H lo hi hs) =
    let newlo = case lo of
                  Nothing -> h
                  Just x  -> min x h
        newhi = case hi of
                  Nothing -> h
                  Just x  -> max x h
    in if elem h hs
         then Nothing
         else if (newhi + 1 - newlo) <= nk
                then Just (H (Just newlo) (Just newhi) (h : hs))
                else Nothing

hash hf (K s a z n) = n + assoc a hf + assoc z hf

cichelli ss =
  case freqSorted (map enKey ss) of
    (ks, mv) -> findhash mv (blocked ks)

keywords =
  [ "as"
  , "case"
  , "class"
  , "data"
  ]

main =
   case cichelli keywords of
       Just hf -> emitHashFun hf
       Nothing -> 0

emitHashFun [] = 0
emitHashFun ((c, n) : hf) = c + n + emitHashFun hf
